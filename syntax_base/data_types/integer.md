# 整型（integer）

## 整数

**整数**（*integer*）是没有小数部分的数字。

> 比如说 `0`，`1`，`-1`，`-2`，`9999999` 等，但是 `0.0` 、`1.0` 和 `-1.11` 等都不是整数。

**整型** 能够囊括所有的数字，虽然不可能无穷大，但已经大到足够使用了。

最大的整型为 `340282366920938463463374607431768211455`，由 `std::u128:MAX` 定义。

最小的整型为 `-170141183460469231731687303715884105728`，由 `std::i128:MIN` 定义。

## 整型的分类

整型可以进一步分为 **有符号整型** 和 **无符号整型** 两种:

- 有符号整型，英文 `signed`，既可以存储正数，也可以存储负数。
- 无符号整型，因为 `unsigned`，只能存储正数。

按照存储空间来说，整型可以进一步划分为 `1字节`、`2字节`、`4字节`、`8字节`、`16字节`。

1 字节 = 8 位，每一位能只能存储二进制 0 或 1，因此每一个字节能够存储的最大数字是 256，而最小数字则是 -127。

| 长度   | 有符号类型 | 无符号类型 |
| ------ | ---------- | ---------- |
| 8 位   | `i8`       | `u8`       |
| 16 位  | `i16`      | `u16`      |
| 32 位  | `i32`      | `u32`      |
| 64 位  | `i64`      | `u64`      |
| 128 位 | `i128`     | `u128`     |
| arch   | `isize`    | `usize`    |

`i32` 是默认的整型，如果我们直接说出一个数字而不说它的数据类型，那么它默认就是 `i32` 。

整型的长度还可以是 `arch`。`arch` 是由 CPU 构架决定的大小的整型类型。大小为 `arch` 的整数在 `x86` 机器上为 `32` 位，在 `x64` 机器上为 `64` 位。

`Arch` 整型通常用于表示容器的大小或者数组的大小，或者数据在内存上存储的位置。

## 定义整型变量

定义整型变量的时候要注意每种整型的最大值和最小值，如果超出可能会赋值失败

```rust
fn main() {
   let result = 10;    // i32 默认
   let age:u32 = 20;
   let sum:i32 = 5-15;
   let mark:isize = 10;
   let count:usize = 30;
   println!("result value is {}",result);
   println!("sum is {} and age is {}",sum,age);
   println!("mark is {} and count is {}",mark,count);
}
```

整型只能保存整数，不能保存有小数点的数字，哪怕小数点后面全是 `0`。如果把一个有小数的数字赋值给整型，会报编译错误

```rust
fn main() {
   let age:u32 = 20.0;//error，expected u32, found floating-point number
}
```

### 整型的字面量

| 数字字面量         | 示例          |
| ------------------ | ------------- |
| 十进制             | `98_222`      |
| 十六进制           | `0xff`        |
| 八进制             | `0o77`        |
| 二进制             | `0b1111_0000` |
| 字节 (仅限于 `u8`) | `b'A'`        |

例如：

```rust
fn main() {
   let result = 98_222;
   let age:u32 = 0xff;
   let sum:i32 = 0o77;
   let mark:isize = 0b1111_0000;
   let count:u8 = b'A';
   println!("result value is {}",result);
   println!("sum is {} and age is {}",sum,age);
   println!("mark is {} and count is {}",mark,count);
}
```

运行结果：

```shell
result value is 98222
sum is 63 and age is 255
mark is 240 and count is 65
```

## 整型的范围

每种整型并不都是能存储任意数字的，每种整型只能装下固定大小的数字，但总体上，大的整型能装下小的整型。

每种 **有符号整型** 能够存储的最小值为 `-(2^(n-1))`，能够存储的最大值为 `2^(n-1) -1`。

每种 **无符号整型** 能够存储的最小值为 `0`，能够存储的最大值为 `2^n - 1`。

其中 `n` 是指数据类型的大小。

> 例如一个 8 位有符号整型 `i8`，它能够存储的最小值为 `-(2^(8-1)) = -128`。最大值为 `(2^(8-1)-1) = 127`。

> 例如一个 8 位无符号整型 `u8`，它能够存储的最小值为 `0`，能够存储的最大值为 `2^8-1 = 255`。

### 整型溢出

每种整型并不都是能存储任意数字的，每种整型只能装下固定大小的数字。如果给予的数字超出了整型的范围则会发生溢出。

比如一个 `i8` 能够存储的最小值是 `0`，如果我们让它来存储 `-1` 则会发生溢出。

**当发生数据溢出时，Rust 抛出一个错误指示数据溢出**。

例如下面的代码，编译会报错。

```rust
fn main() {
   let age:u8 = 255;

   // u8 只能存储 0 to 255 
   let weight:u8 = 256;   // 溢出值为 0
   let height:u8 = 257;   // 溢出值为 1
   let score:u8 = 258;    // 溢出值为 2

   println!("age is {} ",age);
   println!("weight is {}",weight);
   println!("height is {}",height);
   println!("score is {}",score);
}
```

编译运行以上代码，报错信息如下

```shell
error: literal out of range for u8
 --> src/main.rs:5:20
  |
5 |    let weight:u8 = 256;   // 溢出值为 0
  |                    ^^^
  |
  = note: #[deny(overflowing_literals)] on by default

error: literal out of range for u8
 --> src/main.rs:6:20
  |
6 |    let height:u8 = 257;   // 溢出值为 1
  |                    ^^^

error: literal out of range for u8
 --> src/main.rs:7:19
  |
7 |    let score:u8 = 258;    // 溢出值为 2
  |                   ^^^
```

在当使用 `--release` 参数进行发布（release）模式构建时，Rust **不**检测会导致 panic 的整型溢出。相反当检测到整型溢出时，Rust 会进行一种被称为二进制补码包裹（*two’s complement wrapping*）的操作。简而言之，大于该类型最大值的数值会被“包裹”成该类型能够支持的对应数字的最小值。比如在 `u8` 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖整型溢出包裹的行为不是一种正确的做法。
